# 算法

选择算法的标准：程序简洁程度、编码难易程度、运算效率、内存使用量

伪代码：

► 变量用英文表示， 省略声明与类型
► 结构语句使用多数编程语言通用的if、while 、for语句
► 程序块用缩进表示，不使用“{}”
► 使用C/C++ 语言的运算符。比如代入运算为“=”， 等价运算为
    辑运算符用==” 
► 数组A的长度（ 体积）用A.length 表示
► 数组A 的第i项元素用A[i] 表示。
► 数组下标视情况分別使用0 起点1 和1 起点

# 初级算法

## 穷竭搜索

### 深度优先搜索

从某个状态开始，不断转移，直至无法转移，回退到前一步，再继续转移到其他状态，直到找到最终解。通常采用**递归函数**或者**栈**（Stack）来实现。

### 广度优先搜索

从初始状态开始，总是先搜索至距离初始状态近的状态。每个状态都只经过一次，因此复杂度为O(状态数*转移方式数)。通常采用**循环**或**队列**（Queue）实现。

### 细节方面优化

1. 特殊状态枚举：可行解空间多数可采用DFS，但当其比较特殊时，可简短地实现。
   - 全排列使用STL中的next_permutation
   - 组合或子集使用**位运算**
2. 剪枝：明确知道从当前状态无论如何转移都不会存在解的情况下，不再继续搜索而是**直接跳过**。
3. 栈内存与堆内存：
   - **main函数中的局部变量存储在栈**内存中，统一分配后不再扩大，影响栈深度，与机器设置有关。通常，C++中执行上万次递归是可行的。
   - **new或malloc的分配的是堆内存**，全局变量存储在堆内存中，使用全局变量代替局部变量可减少栈溢出的风险。
4. 加深深度优先搜索（IDDFS）：初始的DFS递归深度限制为1，在找到解之前不断增加递归深度。

## 贪心算法

遵循某种规律，不断贪心选取当前最优策略。

贪心算法正确性证明：

- 与其它选择方案相比，该算法并不会得到更差的解（归纳法）
- 不存在其他的解决方案（反证法）

https://cloud.tencent.com/developer/article/1556608

## 动态规划（DP）

### 细节方面的优化

1. 使用memset初始化
2. 重复循环数组
3. dp仅bool是一种浪费
4. 根据规模改变DP对象

### 经典模型

1. 背包问题（01背包，完全背包）
2. 最长子序列（LCS，LIS）
3. 划分数（第二类Stirling数，Bell数）