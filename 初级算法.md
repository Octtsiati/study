# 算法

## 选择算法的标准：

程序简洁程度、编码难易程度、运算效率、内存使用量

- 空间复杂度$$S(n)$$——占用存储单元的长度

空间复杂度太大会爆掉，无法出结果

空间复杂度C*N

- 时间复杂度$$T(n)$$——耗费时间的长度

时间复杂度太大会导致运行时间太久  

​     机器运算加减法的速度要比乘除法的速度快很多，故加减乘除都有事，只算乘除，加减忽略不计

### 复杂度分析

![image-20220922101815298](C:\Users\Monica\AppData\Roaming\Typora\typora-user-images\image-20220922101815298.png)

如上图：第一个代码中每次都使用了i次乘法（指数运算中i-1次+前面一次）

在分析一般算法的效率时，常关注下面两种复杂度

1. 最坏情况复杂度$$T_{worst}(n)$$
2. 平均复杂度$T_{arg}(n)$

偏向于计算最坏情况复杂度（平均不好定义） 

渐进表示法：$T(n)=O(f(n))$
$$
log n<n<n log n<n^2<n^3<2^n<n !
$$
![image-20220922103349919](C:\Users\Monica\AppData\Roaming\Typora\typora-user-images\image-20220922103349919.png)

$n^2$可以尽可能降到$n log n$,可以很大的加块效率

**若有两段复杂度不同的算法**

- 拼在一起则总时间即为两段之和，上界即为较大的那个
- 嵌套则上界为二者的乘积 

![](C:\Users\Monica\AppData\Roaming\Typora\typora-user-images\image-20220922104113465.png)

![image-20220922105703664](C:\Users\Monica\AppData\Roaming\Typora\typora-user-images\image-20220922105703664.png)

伪代码：

► 变量用英文表示， 省略声明与类型
► 结构语句使用多数编程语言通用的if、while 、for语句
► 程序块用缩进表示，不使用“{}”
► 使用C/C++ 语言的运算符。比如代入运算为“=”， 等价运算为
    辑运算符用==” 
► 数组A的长度（ 体积）用A.length 表示
► 数组A 的第i项元素用A[i] 表示。
► 数组下标视情况分別使用0 起点1 和1 起点

# 初级算法

## 分而治之

## 穷竭搜索

### 深度优先搜索

从某个状态开始，不断转移，直至无法转移，回退到前一步，再继续转移到其他状态，直到找到最终解。通常采用**递归函数**或者**栈**（Stack）来实现。

### 广度优先搜索

从初始状态开始，总是先搜索至距离初始状态近的状态。每个状态都只经过一次，因此复杂度为O(状态数*转移方式数)。通常采用**循环**或**队列**（Queue）实现。

### 细节方面优化

1. 特殊状态枚举：可行解空间多数可采用DFS，但当其比较特殊时，可简短地实现。
   - 全排列使用STL中的next_permutation
   - 组合或子集使用**位运算**
2. 剪枝：明确知道从当前状态无论如何转移都不会存在解的情况下，不再继续搜索而是**直接跳过**。
3. 栈内存与堆内存：
   - **main函数中的局部变量存储在栈**内存中，统一分配后不再扩大，影响栈深度，与机器设置有关。通常，C++中执行上万次递归是可行的。
   - **new或malloc的分配的是堆内存**，全局变量存储在堆内存中，使用全局变量代替局部变量可减少栈溢出的风险。
4. 加深深度优先搜索（IDDFS）：初始的DFS递归深度限制为1，在找到解之前不断增加递归深度。

## 贪心算法

遵循某种规律，不断贪心选取当前最优策略。

贪心算法正确性证明：

- 与其它选择方案相比，该算法并不会得到更差的解（归纳法）
- 不存在其他的解决方案（反证法）

https://cloud.tencent.com/developer/article/1556608

## 动态规划（DP）

### 细节方面的优化

1. 使用memset初始化
2. 重复循环数组
3. dp仅bool是一种浪费
4. 根据规模改变DP对象

### 经典模型

1. 背包问题（01背包，完全背包）
2. 最长子序列（LCS，LIS）
3. 划分数（第二类Stirling数，Bell数）

## 二分查找(Binary search)

在一串**有序**数中找key值，则

```c++
int start=0;
int end=length-1;
int mid=(start+end)/2;
while(start<=end){
if(key<a[mid])
    end=mid-1
}
else if(key>a[mid]){
    start=mid+1;
}
```

二分查找最多需要$log_2 n$步
